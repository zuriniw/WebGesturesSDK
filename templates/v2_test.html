<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EyeTubeFieldTest</title>
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'JetBrains Mono', monospace;
      margin: 0;
      padding: 0;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      background-color: #f1f1f1;
      border-bottom: 1px solid #ccc;
    }

    .logo {
      display: flex;
      align-items: center;
    }

    .logo img {
      height: 40px;
      margin-right: 10px;
    }

    .search-bar {
      flex-grow: 1;
      margin: 0 20px;
    }

    .search-bar input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .main-video .video-thumbnail {
      width: 100%;
      height: 500px;
      background-color: #000;
      border-radius: 8px;
    }

    .sidebar-videos .video-thumbnail {
      width: 100%;
      height: 150px;
      background-color: #000;
      border-radius: 8px;
      background-size: cover;
      background-position: center center;
    }

    .video-title {
      padding: 10px 0;
      font-size: 16px;
      font-weight: bold;
    }

    #cursor {
      position: fixed;
      width: 50px;
      height: 50px;
      background: transparent;
      border-radius: 50%;
      border: 2px solid black;
      z-index: 1000;
      pointer-events: none;
      transition: border-color 0.3s ease;
    }

    #cursor.invisible {
      border-color: transparent;
    }

    #calib_cursor {
      position: fixed;
      width: 50px;
      height: 50px;
      background: black;
      border-radius: 50%;
      z-index: 1000;
      pointer-events: none;
    }

    @media (max-width: 576px) {
      .main-video .video-thumbnail {
        height: 250px;
      }
    }

    .highlight {
      box-shadow: 0 0 15px rgba(255, 98, 0, 0.8);
    }

    .text-container {
        padding: 20px 40px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 8px;
        line-height: 1.6;
        font-size: 1.1em;
        position: relative;
        isolation: isolate;
        mix-blend-mode: normal;
    }

    .paragraph-chunk {
        margin-bottom: 30px;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 5px;
        transition: all 0.3s ease;
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        z-index: 1;
        isolation: isolate;
        mix-blend-mode: normal;
    }

    .paragraph-chunk:hover {
        background-color: #e9ecef;
    }

    .paragraph-chunk.highlight {
        background-color: #ffffff !important;
        box-shadow: none;
    }

    body::-webkit-scrollbar {
        width: 12px;
    }

    body::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 6px;
    }

    body::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 6px;
    }

    body::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    .page-title {
        text-align: center;
        padding: 15px 0;
        margin-bottom: 15px;
        font-size: 1.4em;
        font-weight: bold;
        color: #333;
        border-bottom: 2px solid #eee;
        font-family: 'JetBrains Mono', monospace;
    }

    .time-counter {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.1);
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.9em;
        color: #666;
        z-index: 999;
        display: block !important;
        font-family: 'JetBrains Mono', monospace;
    }

    .control-panel {
        position: fixed;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1001;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px 20px;
        border-radius: 15px;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
        display: flex;
        gap: 20px;
    }

    .control-button {
        padding: 5px 12px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.9em;
        background-color: #333;
        color: white;
        transition: all 0.3s ease;
        font-family: 'JetBrains Mono', monospace;
    }

    .control-button:hover {
        background-color: #666;
    }

    .control-button:disabled {
        background-color: #999;
        cursor: not-allowed;
    }

    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #333;
        transition: .4s;
        border-radius: 24px;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
        background-color: #666;
    }

    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(26px);
    }

    .toggle-label {
        font-size: 0.9em;
        color: #333;
        margin-left: 8px;
        font-family: 'JetBrains Mono', monospace;
    }

    .calibration-mode .paragraph-chunk {
        opacity: 0;
        pointer-events: none;
    }

    .calibration-mode #calib_cursor {
        display: block;
    }

    .reading-mode #calib_cursor {
        display: none;
    }

    .calibration-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: #333;
        font-size: 1.2em;
        z-index: 999;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        transition: opacity 0.5s ease;
    }

    .calibration-mode .text-container {
        opacity: 0;
        pointer-events: none;
    }

    .calibration-mode .calibration-message {
        opacity: 1;
    }

    .reading-mode .calibration-message {
        opacity: 0;
        pointer-events: none;
    }

    .heatmap-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.6;
        z-index: 2;
        display: none;
    }

    .heatmap-canvas.visible {
        display: block;
    }

    .text-container-wrapper {
        position: relative;
    }

    .playback-controls {
        position: fixed;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1001;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 15px 20px;
        border-radius: 15px;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
        display: none;
        gap: 20px;
    }

    .playback-mode .playback-controls {
        display: flex;
        gap: 10px;
    }

    .playback-mode .control-panel {
        display: none;
    }

    .playback-button {
        padding: 8px 20px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.9em;
        background-color: #333;
        color: white;
        transition: all 0.3s ease;
        font-family: 'JetBrains Mono', monospace;
    }

    .playback-button:hover {
        background-color: #666;
    }

    .playback-mode .time-counter {
        display: none;
    }

    .playback-mode #calib_cursor {
        display: none;
    }

    .playback-mode .calibration-message {
        display: none;
    }

    .main-content-wrapper {
        padding: 20px 0;
        margin-bottom: 60px;
    }

    .playback-mode .paragraph-chunk:hover {
        background-color: #f8f9fa;
        cursor: default;
    }

    #linesContainer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        pointer-events: none;
        z-index: 1001;
    }

    #linesCanvas {
        width: 100%;
        position: absolute;
        top: 0;
        left: 0;
    }

    .paragraph-chunk {
        z-index: 1;
    }

    .time-counter {
        z-index: 999;
    }

    .knitting-mode .time-counter {
        display: none !important;
    }

    .knitting-mode .paragraph-chunk {
        box-shadow: none !important;
    }

    .knitting-mode .control-panel {
        display: none !important;
    }

    .playback-controls {
        display: none;
    }

    .knitting-mode .playback-controls {
        display: flex !important;
    }

    /* Add styles for calibration mode controls */
    .calibration-mode .control-panel > *:not(#startButton) {
        display: none !important;
    }

    /* Add style for ripple canvas */
    .ripple-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1002;  /* Higher than lines and points */
    }
  </style>
</head>
<body style="height: 100vh; overflow-y: auto;">
    <canvas id="heatmapCanvas" class="heatmap-canvas"></canvas>
    <canvas id="pointsCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 999;"></canvas>
    <div class="page-title">
        Knitting Text: Inquiry into Reading Entanglement
    </div>
    
    <div class="container-fluid main-content-wrapper">
        <div class="row main-content">
            <div id="linesContainer" style="position: absolute; top: 0; left: 0; width: 100%; pointer-events: none;">
                <canvas id="linesCanvas" style="width: 100%;"></canvas>
            </div>
            <div class="col-6">
                <div class="text-container" id="leftTextContainer">
                    <canvas id="leftHeatmapCanvas" class="heatmap-canvas"></canvas>
                    <!-- Left paragraphs will be inserted here -->
                </div>
            </div>
            <div class="col-6">
                <div class="text-container" id="rightTextContainer">
                    <canvas id="rightHeatmapCanvas" class="heatmap-canvas"></canvas>
                    <!-- Right paragraphs will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <div class="control-panel">
        <button id="startButton" class="control-button">Start Reading</button>
        
        <div style="display: flex; align-items: center;">
            <label class="toggle-switch">
                <input type="checkbox" id="cursorToggle" checked>
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">Cursor</span>
        </div>

        <div style="display: flex; align-items: center;">
            <label class="toggle-switch">
                <input type="checkbox" id="timerToggle" checked>
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">Timer</span>
        </div>

        <div style="display: flex; align-items: center;">
            <label class="toggle-switch">
                <input type="checkbox" id="heatmapToggle">
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">Heatmap</span>
        </div>

        <button id="finishButton" class="control-button" disabled>Finish Reading</button>
    </div>

    <div class="playback-controls">
        <button id="playPauseButton" class="playback-button">Pause</button>
        <button id="resetButton" class="playback-button">Reset</button>
    </div>

    <div class="calibration-message">
        Please follow the black target circle with your eyes<br>
        to complete the calibration process
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
    <script src="/eyeCanvas.js"></script>
    <script>
        function disableEyeTracking() {
            if (window.eyeGestures) {
                window.eyeGestures.disconnect();
                if (window.eyeGestures.socket) {
                    window.eyeGestures.socket.removeAllListeners();
                    window.eyeGestures.socket.disconnect();
                }
            }
            if (window.eyeTrackingInterval) {
                clearInterval(window.eyeTrackingInterval);
            }
            document.removeEventListener('visibilitychange', window.visibilityChangeHandler);
        }

        class Paragraph {
            constructor(text, id) {
                this.text = text;
                this.id = id;
                this.element = this.createElement();
                this.timeSpent = 0;
                this.isHighlighted = false;
                this.lastUpdateTime = null;
                this.isOutOfScreen = false;
                this.point = null;
                this.pointElement = this.createPointElement();
                this.rippleRadii = [0];
                this.rippleInterval = null;
                this.activeRipples = new Set();
                this.isPaused = false;
                this.rippleContainers = new Set();
            }

            createPointElement() {
                const point = document.createElement('div');
                point.style.cssText = `
                    position: absolute;
                    width: 8px;
                    height: 8px;
                    background-color: transparent;
                    border: 2px solid black;
                    border-radius: 50%;
                    display: none;
                    z-index: 1000;
                    transition: all 0.3s ease;
                `;
                return point;
            }

            startRippleEffect() {
                if (this.isPaused) {
                    this.isPaused = false;
                } else {
                    this.activeRipples.add([0]);
                }

                this.rippleInterval = setInterval(() => {
                    this.activeRipples.forEach(rippleSet => {
                        rippleSet.push(rippleSet[rippleSet.length - 1] + 2.4);
                        if (rippleSet.length > 10) {
                            rippleSet.shift();
                        }
                    });
                    this.drawRipple();
                }, 100);
            }

            drawRipple() {
                const pointRect = this.pointElement.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const centerX = pointRect.left + pointRect.width / 2;
                const centerY = pointRect.top + scrollTop + pointRect.height / 2;

                const rippleCanvas = document.createElement('canvas');
                rippleCanvas.className = 'ripple-canvas';
                rippleCanvas.width = window.innerWidth;
                rippleCanvas.height = document.documentElement.scrollHeight;
                rippleCanvas.style.top = '0';
                rippleCanvas.style.position = 'absolute';

                const rippleCtx = rippleCanvas.getContext('2d');
                rippleCtx.clearRect(0, 0, rippleCanvas.width, rippleCanvas.height);

                this.activeRipples.forEach(rippleSet => {
                    rippleSet.forEach(radius => {
                        rippleCtx.beginPath();
                        rippleCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        rippleCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        rippleCtx.lineWidth = 2;
                        rippleCtx.stroke();
                    });
                });

                const rippleContainer = document.createElement('div');
                rippleContainer.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: ${document.documentElement.scrollHeight}px;
                    pointer-events: none;
                    z-index: 1002;
                `;
                rippleContainer.appendChild(rippleCanvas);
                document.body.appendChild(rippleContainer);
                this.rippleContainers.add(rippleContainer);
            }

            stopRippleEffect() {
                clearInterval(this.rippleInterval);
                this.isPaused = true;
            }

            resetRipples() {
                this.activeRipples.clear();
                this.isPaused = false;
                this.rippleContainers.forEach(container => {
                    if (document.body.contains(container)) {
                        document.body.removeChild(container);
                    }
                });
                this.rippleContainers.clear();
            }

            initializeRandomPoint() {
                const padding = 50;
                const centerX = this.element.offsetWidth / 2;
                const centerY = this.element.offsetHeight / 2;
                const maxOffset = Math.min(centerX, centerY) / 2;
                
                this.point = {
                    left: centerX + (Math.random() - 0.5) * maxOffset,
                    top: centerY + (Math.random() - 0.5) * maxOffset
                };
                
                this.pointElement.style.left = `${this.point.left}px`;
                this.pointElement.style.top = `${this.point.top}px`;
            }

            drawPoint(ctx) {
                if (this.point) {
                    ctx.beginPath();
                    ctx.arc(this.point.x, this.point.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                }
            }

            createElement() {
                const div = document.createElement('div');
                div.className = 'paragraph-chunk';
                div.id = `paragraph-${this.id}`;
                
                const textDiv = document.createElement('div');
                textDiv.textContent = this.text;
                
                const counterDiv = document.createElement('div');
                counterDiv.className = 'time-counter';
                counterDiv.textContent = '0.0s';
                
                div.appendChild(textDiv);
                div.appendChild(counterDiv);
                
                return div;
            }

            updateCounter() {
                const now = Date.now();
                if (this.isHighlighted && this.lastUpdateTime && !this.isOutOfScreen) {
                    this.timeSpent += now - this.lastUpdateTime;
                }
                this.lastUpdateTime = now;
                
                const seconds = (this.timeSpent / 1000).toFixed(1);
                const counterDiv = this.element.querySelector('.time-counter');
                counterDiv.textContent = `${seconds}s`;

                if (document.body.classList.contains('playback-mode')) {
                    const scale = 1 + (this.timeSpent / 1000) * 0.5;
                    this.pointElement.style.transform = `scale(${scale})`;

                    if (this.isHighlighted && this.rippleRadii.length === 0) {
                        this.startRippleEffect();
                    } else if (!this.isHighlighted) {
                        this.stopRippleEffect();
                    }
                }
            }

            setHighlight(isHighlighted, isRecording, isOutOfScreen) {
                this.isHighlighted = isHighlighted;
                
                if (document.body.classList.contains('knitting-mode')) {
                    this.pointElement.style.display = 'block';
                    if (isHighlighted) {
                        const darkness = Math.min(0.5, this.timeSpent / 10000);
                        this.element.style.backgroundColor = `rgba(0, 0, 0, ${darkness})`;
                        this.element.style.color = darkness > 0.3 ? 'white' : 'black';
                        this.element.style.boxShadow = 'none';
                        this.element.style.border = 'none';
                        this.element.style.position = 'relative';
                        this.element.style.zIndex = '1';
                    } else {
                        const darkness = Math.min(0.5, this.timeSpent / 10000);
                        this.element.style.backgroundColor = `rgba(0, 0, 0, ${darkness})`;
                        this.element.style.color = darkness > 0.3 ? 'white' : 'black';
                        this.element.style.boxShadow = 'none';
                        this.element.style.border = 'none';
                        this.element.style.position = 'relative';
                        this.element.style.zIndex = '1';
                    }
                } else {
                    this.element.classList.toggle('highlight', isHighlighted);
                }
            }

            appendTo(container) {
                container.appendChild(this.element);
                this.element.appendChild(this.pointElement);
                this.initializeRandomPoint();
            }

            hideCounter(hide) {
                const counterDiv = this.element.querySelector('.time-counter');
                if (hide) {
                    counterDiv.classList.add('hidden');
                } else {
                    counterDiv.classList.remove('hidden');
                }
            }

            resetCounter() {
                this.timeSpent = 0;
                this.lastUpdateTime = null;
                this.isHighlighted = false;
                const counterDiv = this.element.querySelector('.time-counter');
                counterDiv.textContent = '0.0s';
            }
        }

        class FocusManager {
            constructor() {
                this.lastActiveTime = Date.now();
                this.lastActiveParagraph = null;
                this.outOfScreenTimer = null;
                this.TIMEOUT_DURATION = 4000;
                this.isObscured = false;
                this.isOutOfScreen = false;
            }

            handleCursorOutOfScreen() {
                this.isOutOfScreen = true;
                if (this.outOfScreenTimer) clearTimeout(this.outOfScreenTimer);
                
                this.outOfScreenTimer = setTimeout(() => {
                    document.querySelectorAll('.text-container').forEach(container => {
                        container.classList.add('fully-obscured');
                    });
                    this.lastActiveParagraph = null;
                    this.isObscured = true;
                }, this.TIMEOUT_DURATION);
            }

            handleCursorInScreen() {
                this.isOutOfScreen = false;
                if (this.outOfScreenTimer) {
                    clearTimeout(this.outOfScreenTimer);
                    this.outOfScreenTimer = null;
                }
                if (this.isObscured) {
                    document.querySelectorAll('.text-container').forEach(container => {
                        container.classList.remove('fully-obscured');
                    });
                    this.isObscured = false;
                }
            }

            updateLastActiveParagraph(paragraph) {
                if (!this.isObscured) {
                    this.lastActiveParagraph = paragraph;
                    this.lastActiveTime = Date.now();
                }
            }

            isActive() {
                return !this.isObscured;
            }
        }

        function isInVerticalBounds(cursorY, rect) {
            return cursorY >= rect.top && cursorY <= rect.bottom;
        }

        function findNearestParagraph(cursorX, cursorY, paragraphs) {
            const midScreen = window.innerWidth / 2;
            const isLeftSide = cursorX < midScreen;
            
            const sideParagraphs = paragraphs.filter(paragraph => {
                const rect = paragraph.element.getBoundingClientRect();
                return (cursorX < midScreen) === (rect.left < midScreen);
            });

            if (sideParagraphs.length === 0) return null;

            const paragraphRects = sideParagraphs.map(paragraph => ({
                paragraph,
                rect: paragraph.element.getBoundingClientRect()
            })).sort((a, b) => a.rect.top - b.rect.top);

            for (const {paragraph, rect} of paragraphRects) {
                if (isInVerticalBounds(cursorY, rect)) {
                    return paragraph;
                }
            }

            let nearestParagraph = null;
            let minDistance = Infinity;

            paragraphRects.forEach(({paragraph, rect}, index) => {
                let distanceToTop = Math.abs(cursorY - rect.top);
                if (distanceToTop < minDistance) {
                    minDistance = distanceToTop;
                    nearestParagraph = paragraph;
                }

                let distanceToBottom = Math.abs(cursorY - rect.bottom);
                if (distanceToBottom < minDistance) {
                    minDistance = distanceToBottom;
                    nearestParagraph = paragraph;
                }

                if (index < paragraphRects.length - 1) {
                    const nextRect = paragraphRects[index + 1].rect;
                    const gapMiddle = (rect.bottom + nextRect.top) / 2;
                    
                    if (cursorY > rect.bottom && cursorY < nextRect.top) {
                        const distanceToThis = Math.abs(cursorY - rect.bottom);
                        const distanceToNext = Math.abs(cursorY - nextRect.top);
                        if (distanceToThis <= distanceToNext) {
                            return paragraph;
                        } else {
                            return paragraphRects[index + 1].paragraph;
                        }
                    }
                }
            });

            return nearestParagraph;
        }

        function checkOverlap(cursor, paragraphs, isRecording, focusManager) {
            const cursorRect = cursor.getBoundingClientRect();
            const cursorX = cursorRect.left + cursorRect.width / 2;
            const cursorY = cursorRect.top + cursorRect.height / 2;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (cursorX < 0 || cursorY < 0 || 
                cursorX > viewportWidth || cursorY > viewportHeight || 
                !document.hasFocus()) {
                
                focusManager.handleCursorOutOfScreen();
                
                if (focusManager.lastActiveParagraph && 
                    Date.now() - focusManager.lastActiveTime < focusManager.TIMEOUT_DURATION) {
                    focusManager.lastActiveParagraph.setHighlight(true, isRecording, true);
                }
                return;
            }

            focusManager.handleCursorInScreen();

            if (focusManager.isActive()) {
                const nearestParagraph = findNearestParagraph(cursorX, cursorY, paragraphs);
                
                paragraphs.forEach(paragraph => {
                    const isNearest = paragraph === nearestParagraph;
                    paragraph.setHighlight(isNearest, isRecording, false);
                    if (isNearest) {
                        focusManager.updateLastActiveParagraph(paragraph);
                    }
                });
            }
        }

        class Heatmap {
            constructor(canvas, container) {
                this.canvas = canvas;
                this.container = container;
                this.ctx = canvas.getContext('2d');
                this.points = [];
                this.maxPoints = 1000;
                this.radius = 30;
                this.intensity = 0.05;
                this.decay = 0.995;
                this.colorScale = [
                    { r: 0, g: 0, b: 255, a: 0 },
                    { r: 255, g: 0, b: 0, a: 0.5 }
                ];
                
                this.resizeCanvas();
                this.container.addEventListener('scroll', () => this.resizeCanvas());
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = this.container.scrollHeight;
                this.draw();
            }

            addPoint(x, y) {
                const rect = this.container.getBoundingClientRect();
                const scrollTop = this.container.scrollTop;
                const relativeX = x - rect.left;
                const relativeY = y - rect.top + scrollTop;

                if (relativeX >= 0 && relativeX <= rect.width &&
                    relativeY >= 0 && relativeY <= this.container.scrollHeight) {
                    this.points.push({ 
                        x: relativeX, 
                        y: relativeY, 
                        intensity: this.intensity 
                    });
                    if (this.points.length > this.maxPoints) {
                        this.points.shift();
                    }
                }
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            draw() {
                this.clear();
                
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;

                this.points = this.points.filter(point => {
                    point.intensity *= this.decay;
                    return point.intensity > 0.001;
                });

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        let heat = 0;
                        
                        this.points.forEach(point => {
                            const distance = Math.sqrt(
                                Math.pow(x - point.x, 2) + 
                                Math.pow(y - point.y, 2)
                            );
                            if (distance < this.radius) {
                                heat += (1 - distance / this.radius) * point.intensity;
                            }
                        });

                        heat = Math.min(1, Math.max(0, heat));

                        const index = (y * this.canvas.width + x) * 4;
                        const color = this.getColor(heat);
                        data[index] = color.r;
                        data[index + 1] = color.g;
                        data[index + 2] = color.b;
                        data[index + 3] = Math.floor(color.a * 255);
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);
            }

            getColor(value) {
                const color1 = this.colorScale[0];
                const color2 = this.colorScale[1];
                
                return {
                    r: Math.floor(color1.r + (color2.r - color1.r) * value),
                    g: Math.floor(color1.g + (color2.g - color1.g) * value),
                    b: Math.floor(color1.b + (color2.b - color1.b) * value),
                    a: color1.a + (color2.a - color1.a) * value
                };
            }
        }

        class ReadingRecorder {
            constructor() {
                this.paragraphEvents = [];
                this.startTime = null;
                this.isRecording = false;
                this.recordingDuration = 0;
            }

            startRecording() {
                this.isRecording = true;
                this.startTime = Date.now();
            }

            recordParagraphEvent(paragraphId, isHighlighted, timestamp) {
                if (!this.isRecording) return;
                const relativeTime = timestamp - this.startTime;
                this.paragraphEvents.push({
                    paragraphId,
                    isHighlighted,
                    time: relativeTime
                });
                this.recordingDuration = Math.max(this.recordingDuration, relativeTime);
            }

            stopRecording() {
                this.isRecording = false;
            }
        }

        class PlaybackController {
            constructor(recorder, paragraphs) {
                this.recorder = recorder;
                this.paragraphs = paragraphs;
                this.currentTime = 0;
                this.isPlaying = true;
                this.playbackSpeed = this.recorder.recordingDuration / 10000;
                this.isFinished = false;
                this.paragraphTimers = new Map();
                
                this.linesCanvas = document.getElementById('linesCanvas');
                this.linesCtx = this.linesCanvas.getContext('2d');
                this.lastHighlightedPoint = null;
                this.previousHighlightedParagraph = null;
                this.connections = [];
                this.initializeCanvas();
            }

            initializeCanvas() {
                this.linesCanvas.width = window.innerWidth;
                this.linesCanvas.height = document.documentElement.scrollHeight;

                window.addEventListener('resize', () => {
                    this.linesCanvas.width = window.innerWidth;
                    this.linesCanvas.height = document.documentElement.scrollHeight;
                    this.redrawAllLines();
                });

                this.linesCtx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                this.linesCtx.lineWidth = 2;
            }

            drawLineTo(fromParagraph, toParagraph) {
                if (!fromParagraph || !toParagraph) return;

                this.connections.push({
                    from: fromParagraph,
                    to: toParagraph
                });

                this.redrawAllLines();
            }

            redrawAllLines() {
                this.linesCtx.clearRect(0, 0, this.linesCanvas.width, this.linesCanvas.height);

                this.connections.forEach(connection => {
                    const fromRect = connection.from.pointElement.getBoundingClientRect();
                    const toRect = connection.to.pointElement.getBoundingClientRect();

                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                    const fromX = fromRect.left + fromRect.width / 2;
                    const fromY = fromRect.top + fromRect.height / 2 + scrollTop;
                    const toX = toRect.left + toRect.width / 2;
                    const toY = toRect.top + toRect.height / 2 + scrollTop;

                    this.linesCtx.beginPath();
                    this.linesCtx.moveTo(fromX, fromY);
                    this.linesCtx.lineTo(toX, toY);
                    this.linesCtx.stroke();
                });
            }

            play() {
                if (!this.isFinished) {
                    this.isPlaying = true;
                }
            }

            pause() {
                this.isPlaying = false;
            }

            restart() {
                this.currentTime = 0;
                this.isPlaying = true;
                this.isFinished = false;
                this.playbackSpeed = this.recorder.recordingDuration / 10000;
                
                this.connections = [];
                this.linesCtx.clearRect(0, 0, this.linesCanvas.width, this.linesCanvas.height);
                this.previousHighlightedParagraph = null;

                this.paragraphs.forEach(paragraph => {
                    paragraph.setHighlight(false, true, false);
                    paragraph.timeSpent = 0;
                    paragraph.updateCounter();
                    paragraph.resetRipples();
                });
                this.updateParagraphStates(0);
            }

            updateParagraphStates(time) {
                const events = this.recorder.paragraphEvents.filter(event => event.time <= time);
                if (events.length === 0) {
                    this.paragraphs.forEach(paragraph => {
                        paragraph.setHighlight(false, true, false);
                        paragraph.timeSpent = 0;
                        paragraph.updateCounter();
                    });
                    return;
                }

                const paragraphStates = new Map();
                const timeSpent = new Map();

                let lastEventTime = 0;
                events.forEach(event => {
                    paragraphStates.forEach((isHighlighted, paragraphId) => {
                        if (isHighlighted) {
                            const currentTimeSpent = timeSpent.get(paragraphId) || 0;
                            timeSpent.set(paragraphId, currentTimeSpent + (event.time - lastEventTime));
                        }
                    });

                    paragraphStates.set(event.paragraphId, event.isHighlighted);
                    lastEventTime = event.time;
                });

                paragraphStates.forEach((isHighlighted, paragraphId) => {
                    if (isHighlighted) {
                        const currentTimeSpent = timeSpent.get(paragraphId) || 0;
                        const additionalTime = time - lastEventTime;
                        timeSpent.set(paragraphId, currentTimeSpent + additionalTime);
                    }
                });

                let currentHighlightedParagraph = null;
                
                this.paragraphs.forEach(paragraph => {
                    paragraph.element.style.border = 'none';
                    paragraph.isHighlighted = false;
                    const darkness = Math.min(0.5, paragraph.timeSpent / 20000);
                    paragraph.element.style.backgroundColor = `rgba(0, 0, 0, ${darkness})`;
                    paragraph.element.style.color = darkness > 0.3 ? 'white' : 'black';
                });

                this.paragraphs.forEach(paragraph => {
                    const isHighlighted = paragraphStates.get(paragraph.id) || false;
                    const totalTimeSpent = timeSpent.get(paragraph.id) || 0;
                    
                    paragraph.isHighlighted = isHighlighted;
                    paragraph.timeSpent = totalTimeSpent;
                    paragraph.updateCounter();

                    if (isHighlighted) {
                        currentHighlightedParagraph = paragraph;
                    }
                });

                if (currentHighlightedParagraph) {
                    currentHighlightedParagraph.element.style.border = '2px solid black';
                    currentHighlightedParagraph.element.style.backgroundColor = '#ffffff';
                    currentHighlightedParagraph.element.style.position = 'relative';
                    currentHighlightedParagraph.element.style.zIndex = '2';
                    currentHighlightedParagraph.element.style.isolation = 'isolate';
                    currentHighlightedParagraph.element.style.mixBlendMode = 'normal';
                    if (currentHighlightedParagraph !== this.previousHighlightedParagraph) {
                        currentHighlightedParagraph.startRippleEffect();
                    }
                }

                if (this.previousHighlightedParagraph && 
                    currentHighlightedParagraph !== this.previousHighlightedParagraph) {
                    this.previousHighlightedParagraph.stopRippleEffect();
                }

                if (currentHighlightedParagraph && 
                    this.previousHighlightedParagraph && 
                    currentHighlightedParagraph !== this.previousHighlightedParagraph &&
                    !this.isFinished) {
                    this.drawLineTo(this.previousHighlightedParagraph, currentHighlightedParagraph);
                }
                this.previousHighlightedParagraph = currentHighlightedParagraph;
            }

            update(deltaTime) {
                if (!this.isPlaying || this.isFinished) {
                    if (this.isFinished) {
                        this.paragraphs.forEach(paragraph => {
                            const darkness = Math.min(0.5, paragraph.timeSpent / 20000);
                            paragraph.element.style.backgroundColor = `rgba(0, 0, 0, ${darkness})`;
                            paragraph.element.style.color = darkness > 0.3 ? 'white' : 'black';
                            paragraph.element.style.border = 'none';
                            paragraph.element.style.outline = 'none';
                            paragraph.element.style.boxShadow = 'none';
                            paragraph.isHighlighted = false;
                            paragraph.element.classList.remove('highlight');
                            paragraph.element.style.zIndex = '1';
                            paragraph.element.style.position = 'relative';
                        });
                        this.previousHighlightedParagraph = null;
                        this.paragraphs.forEach(p => {
                            if (p.rippleInterval) {
                                clearInterval(p.rippleInterval);
                            }
                            p.pointElement.style.display = 'block';
                        });
                    }
                    return;
                }

                this.currentTime += deltaTime * this.playbackSpeed;
                
                if (this.currentTime > this.recorder.recordingDuration) {
                    this.isFinished = true;
                    this.isPlaying = false;
                    this.updateParagraphStates(this.recorder.recordingDuration);
                    const playPauseButton = document.getElementById('playPauseButton');
                    playPauseButton.textContent = 'Play';
                    return;
                }

                this.updateParagraphStates(this.currentTime);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const leftText = `I have always loved objects of measurement and display such as our  family barometer, both real and imagined. Do you remember Frodo's  sword Sting in The Hobbit? It's one of those fantastic objects. Not  only is it perfectly made for its task-well-balanced, attractive, and  sharp-it has an additional and amazing ability: it detects the presence  of goblins and evil orcs. When danger approaches, Sting glows blue,  anticipating its own need and use. It is a trusty weapon, an infallible warning system, a handsome object, and a fantastic companion-for  a hobbit.

            Sting, the barometer, and so many other steampunk-era objectsvintage car and boat dashboards, analog dials, and stereo interfaceshave material qualities that I respond to. Not only are they delightful to  operate and live with, they have a knowingness about them, a possession of knowledge that they convey, an ability to amplify human abilities. Like a vintage clock, such instruments seem to carry the weight  of experience.

            Even as a kid, I imagined creating objects that were as handy as  Sting and as mystical as the barometer. In those hours I spent in the  workshop with my grandfather (avoiding the Thanksgiving or Christmas hubbub taking place upstairs), we would turn bowls on the lathe,  take apart clocks, build stereo speakers and bike rollers, dream up  and draw fantasy homes or airports. My curiosity carried through my  childhood: at robot camp one summer, we programmed a poodle-size  robot using a complicated series of codes called assembly language,  and, in high school, I learned to program on my first Apple He, making it spin out of control with a recursive algorithm.

            In college, computing opened my eyes to a new world of possibilities for what objects could already do and what they might eventually be able to do. A double major, I found that both physics and fine art  had their own thrilling languages for characterizing the physical world,  each with revelations and enlightenments. My graduate work at Harvard included the building of software-learning simulations like SimCity. Then I came to MIT's Media Lab, a place where programmers  mix with artists, musicians, and educators, and everyone experiments  with technology and computation, seeking to reinvent everything from  cinema to opera to medicine and education. There, I had another revelation: technology could enhance objects in ways that would come  close to, or even surpass, the qualities of the magical objects from folklore and science fiction that I have loved since I was a kid. To make  ordinary things as extraordinary and delightful to use and as pleasing  to live with as my father's barometer and my grandfather's tools, the  human-computer interaction needs to be freed from clicking and dragging. There can (and will) be real flying carpets and should be (and already are) Dick Tracy wrist communicators.`;

            const rightText = `The most pressing question underlying these competing trajectories is this: What is the most natural and desirable-even invisible-way  for human beings to interact with technology without requiring a new  set of skills or constantly needing to learn new languages, gestures, icons, color codes, or button combinations? This question has fascinated me for years, driven me to start up five technology companies,  and pushed me to pursue academic research and teaching at the Media Lab.

            I believe these trajectories-Terminal World, prosthetics/wearables, animism, and enchanted objects-are fluid and transitional. They will all bring some degree of value and will overlap and inform each other.  I have chosen to devote my time and energy to the fourth technology trajectory: enchanted objects. I won't abandon my smartphones or lose interest in the work of my colleagues who are developing wearabies and social robots. I simply believe that the most promising and pleasing future is one where technology infuses ordinary things with a  bit of magic to create a more satisfying interaction and evoke an emotional response.

            Think of this approach to technology as a realization of our fondest fantasies and wildest dreams. A reimagining of flying carpets, talking  mirrors, protective cloaks, animated brooms, and omniscient crystal  balls-as well as cherished everyday objects of our past lives, such as hallway barometers and woodworking tools-things we have always loved, dreamed about, and wanted in our lives. This book is about that reimagining and how to make it a reality. ENCHANTED OBJECTS  humans and machines will be preserved. I disagree. I understand that  category confusion provokes anxiety, that people become disturbed when they're not quite sure if they're talking to a machine or a person.

            But I also believe that natural human-computer interaction has more  benefits than risks. When I was in high school, the standard breakup line was "Let's just  be friends ." The snide retort was "If I wanted another friend, I would have gotten a dog." Given Facebook's and Linkedin's abilities to connect me with hundreds of loose ties (aka "friends"), I don't feel the need for a new set of artificial friends in my life, especially in the form  of awkward, sometimes dim-witted, and often brittle robots.`;

            let paragraphs = [];
            let isReadingMode = false;
            document.body.classList.add('calibration-mode');

            const startButton = document.getElementById('startButton');
            const cursorToggle = document.getElementById('cursorToggle');
            const timerToggle = document.getElementById('timerToggle');
            const cursor = document.getElementById('cursor');

            startButton.addEventListener('click', () => {
                if (!isReadingMode) {
                    isReadingMode = true;
                    document.body.classList.remove('calibration-mode');
                    document.body.classList.add('reading-mode');
                    startButton.disabled = true;
                    startButton.textContent = 'Reading Mode';
                    
                    const finishButton = document.getElementById('finishButton');
                    finishButton.disabled = false;
                    
                    paragraphs.forEach(paragraph => {
                        paragraph.element.style.transition = 'opacity 0.5s ease';
                        paragraph.element.style.opacity = '1';
                        paragraph.element.style.pointerEvents = 'auto';
                    });

                    recorder.startRecording();
                }
            });

            cursorToggle.addEventListener('change', () => {
                cursor.classList.toggle('invisible', !cursorToggle.checked);
            });

            timerToggle.addEventListener('change', () => {
                paragraphs.forEach(paragraph => {
                    paragraph.hideCounter(!timerToggle.checked);
                });
            });

            function populateContainer(containerId, text) {
                const paragraphTexts = text.split('\n\n').map(p => p.trim()).filter(p => p.length > 0);
                const container = document.getElementById(containerId);
                
                paragraphTexts.forEach((text, index) => {
                    const paragraph = new Paragraph(text, `${containerId}-${index}`);
                    paragraph.appendTo(container);
                    paragraphs.push(paragraph);
                });
            }

            populateContainer('leftTextContainer', leftText);
            populateContainer('rightTextContainer', rightText);

            const leftContainer = document.getElementById('leftTextContainer');
            const rightContainer = document.getElementById('rightTextContainer');
            const leftHeatmapCanvas = document.getElementById('leftHeatmapCanvas');
            const rightHeatmapCanvas = document.getElementById('rightHeatmapCanvas');
            
            const leftHeatmap = new Heatmap(leftHeatmapCanvas, leftContainer);
            const rightHeatmap = new Heatmap(rightHeatmapCanvas, rightContainer);

            const heatmapToggle = document.getElementById('heatmapToggle');

            heatmapToggle.addEventListener('change', () => {
                leftHeatmapCanvas.classList.toggle('visible', heatmapToggle.checked);
                rightHeatmapCanvas.classList.toggle('visible', heatmapToggle.checked);
            });

            function animate() {
                if (heatmapToggle.checked) {
                    leftHeatmap.draw();
                    rightHeatmap.draw();
                }
                requestAnimationFrame(animate);
            }
            animate();

            const focusManager = new FocusManager();
            window.focusManager = focusManager;

            setInterval(() => {
                if (isReadingMode) {
                    checkOverlap(cursor, paragraphs, true, focusManager);
                    if (heatmapToggle.checked) {
                        const cursorRect = cursor.getBoundingClientRect();
                        const cursorX = cursorRect.left + cursorRect.width / 2;
                        const cursorY = cursorRect.top + cursorRect.height / 2;
                        
                        leftHeatmap.addPoint(cursorX, cursorY);
                        rightHeatmap.addPoint(cursorX, cursorY);
                    }
                    paragraphs.forEach(paragraph => {
                        if (paragraph.isHighlighted) {
                            paragraph.updateCounter();
                        }
                    });
                }
            }, 100);

            const recorder = new ReadingRecorder();
            const finishButton = document.getElementById('finishButton');
            const playPauseButton = document.getElementById('playPauseButton');
            const resetButton = document.getElementById('resetButton');

            finishButton.addEventListener('click', () => {
                if (isReadingMode) {
                    recorder.stopRecording();
                    isReadingMode = false;
                    document.body.classList.remove('reading-mode');
                    document.body.classList.add('knitting-mode');

                    disableEyeTracking();

                    cursor.style.display = 'none';
                    document.getElementById('calib_cursor').style.display = 'none';
                    document.querySelector('.calibration-message').style.display = 'none';

                    document.querySelectorAll('.time-counter').forEach(counter => {
                        counter.style.display = 'block';
                    });

                    const playbackController = new PlaybackController(recorder, paragraphs);
                    console.log(`Playback speed: ${playbackController.playbackSpeed}x`);

                    playPauseButton.addEventListener('click', () => {
                        if (playbackController.isPlaying) {
                            playbackController.pause();
                            playPauseButton.textContent = 'Play';
                        } else if (!playbackController.isFinished) {
                            playbackController.play();
                            playPauseButton.textContent = 'Pause';
                        }
                    });

                    resetButton.addEventListener('click', () => {
                        playbackController.restart();
                        playPauseButton.textContent = 'Pause';
                    });

                    let lastTime = performance.now();
                    function animate(currentTime) {
                        const deltaTime = currentTime - lastTime;
                        lastTime = currentTime;

                        playbackController.update(deltaTime);
                        requestAnimationFrame(animate);
                    }
                    requestAnimationFrame(animate);

                    paragraphs.forEach(p => {
                        p.initializeRandomPoint();
                        p.pointElement.style.display = 'block';
                    });
                }
            });

            setInterval(() => {
                if (isReadingMode && recorder.isRecording) {
                    const timestamp = Date.now();
                    paragraphs.forEach(paragraph => {
                        recorder.recordParagraphEvent(
                            paragraph.id,
                            paragraph.isHighlighted,
                            timestamp
                        );
                    });
                }
            }, 100);
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const focusManager = window.focusManager;
                focusManager.handleCursorOutOfScreen();
            }
        });
    </script>
</body>
</html>
