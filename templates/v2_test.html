<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EyeTubeFieldTest</title>
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      background-color: #f1f1f1;
      border-bottom: 1px solid #ccc;
    }

    .logo {
      display: flex;
      align-items: center;
    }

    .logo img {
      height: 40px;
      margin-right: 10px;
    }

    .search-bar {
      flex-grow: 1;
      margin: 0 20px;
    }

    .search-bar input {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .main-video .video-thumbnail {
      width: 100%;
      height: 500px;
      background-color: #000;
      border-radius: 8px;
    }

    .sidebar-videos .video-thumbnail {
      width: 100%;
      height: 150px;
      background-color: #000;
      border-radius: 8px;
      background-size: cover;
      background-position: center center;
    }

    .video-title {
      padding: 10px 0;
      font-size: 16px;
      font-weight: bold;
    }

    #cursor {
      position: fixed;
      width: 50px;
      height: 50px;
      background: transparent;
      border-radius: 50%;
      border: 2px solid black;
      z-index: 1000;
      pointer-events: none;
      transition: border-color 0.3s ease;
    }

    #cursor.invisible {
      border-color: transparent;
    }

    #calib_cursor {
      position: fixed;
      width: 50px;
      height: 50px;
      background: black;
      border-radius: 50%;
      z-index: 1000;
      pointer-events: none;
    }

    @media (max-width: 576px) {
      .main-video .video-thumbnail {
        height: 250px;
      }
    }

    .highlight {
      box-shadow: 0 0 15px rgba(255, 98, 0, 0.8);
    }

    .text-container {
        height: 800px;
        overflow-y: auto;
        padding: 20px 40px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 8px;
        line-height: 1.6;
        font-size: 1.1em;
        position: relative;
    }

    .paragraph-chunk {
        margin-bottom: 30px;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 5px;
        transition: all 0.3s ease;
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        position: relative;
    }

    .paragraph-chunk:hover {
        background-color: #e9ecef;
    }

    .paragraph-chunk.highlight {
        box-shadow: 0 0 15px rgba(255, 98, 0, 0.8);
        background-color: #fff3e6;
    }

    .text-container::-webkit-scrollbar {
        width: 12px;
    }

    .text-container::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 6px;
    }

    .text-container::-webkit-scrollbar-thumb {
        background: #888;
        border-radius: 6px;
    }

    .text-container::-webkit-scrollbar-thumb:hover {
        background: #555;
    }

    .page-title {
        text-align: center;
        padding: 15px 0;
        margin-bottom: 15px;
        font-size: 1.8em;
        font-weight: bold;
        color: #333;
        border-bottom: 2px solid #eee;
    }

    .time-counter {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(0, 0, 0, 0.1);
        padding: 5px 10px;
        border-radius: 15px;
        font-size: 0.9em;
        color: #666;
    }

    .control-panel {
        position: fixed;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1001;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 8px 15px;
        border-radius: 15px;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
        display: flex;
        gap: 10px;
    }

    .control-button {
        padding: 5px 12px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.9em;
        background-color: #333;
        color: white;
        transition: all 0.3s ease;
    }

    .control-button:hover {
        background-color: #666;
    }

    .control-button:disabled {
        background-color: #999;
        cursor: not-allowed;
    }

    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #333;
        transition: .4s;
        border-radius: 24px;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }

    .toggle-switch input:checked + .toggle-slider {
        background-color: #666;
    }

    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(26px);
    }

    .toggle-label {
        font-size: 0.9em;
        color: #333;
        margin-left: 8px;
    }

    .calibration-mode .paragraph-chunk {
        opacity: 0;
        pointer-events: none;
    }

    .calibration-mode #calib_cursor {
        display: block;
    }

    .reading-mode #calib_cursor {
        display: none;
    }

    .calibration-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: #333;
        font-size: 1.2em;
        z-index: 999;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        transition: opacity 0.5s ease;
    }

    .calibration-mode .text-container {
        opacity: 0;
        pointer-events: none;
    }

    .calibration-mode .calibration-message {
        opacity: 1;
    }

    .reading-mode .calibration-message {
        opacity: 0;
        pointer-events: none;
    }

    .heatmap-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.6;
        z-index: 2;
        display: none;
    }

    .heatmap-canvas.visible {
        display: block;
    }

    .text-container-wrapper {
        position: relative;
    }
  </style>
</head>
<body style="height: 100vh;">
    <canvas id="heatmapCanvas" class="heatmap-canvas"></canvas>
    <div class="page-title">
        Inquiry into Eye-Gesture Powered Reading Experience
    </div>
    
    <div class="container-fluid" style="margin-top: 20px; margin-bottom: 40px;">
        <div class="row main-content">
            <div class="col-6">
                <div class="text-container" id="leftTextContainer">
                    <canvas id="leftHeatmapCanvas" class="heatmap-canvas"></canvas>
                    <!-- Left paragraphs will be inserted here -->
                </div>
            </div>
            <div class="col-6">
                <div class="text-container" id="rightTextContainer">
                    <canvas id="rightHeatmapCanvas" class="heatmap-canvas"></canvas>
                    <!-- Right paragraphs will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <div class="control-panel">
        <button id="startButton" class="control-button">Start to Read</button>
        
        <div style="display: flex; align-items: center;">
            <label class="toggle-switch">
                <input type="checkbox" id="cursorToggle" checked>
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">Cursor</span>
        </div>

        <div style="display: flex; align-items: center;">
            <label class="toggle-switch">
                <input type="checkbox" id="timerToggle" checked>
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">Timer</span>
        </div>

        <div style="display: flex; align-items: center;">
            <label class="toggle-switch">
                <input type="checkbox" id="heatmapToggle">
                <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">Heatmap</span>
        </div>
    </div>

    <div class="calibration-message">
        Please follow the black target circle with your eyes<br>
        to complete the calibration process
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.js"></script>
    <script src="/eyeCanvas.js"></script>
    <script>
        class Paragraph {
            constructor(text, id) {
                this.text = text;
                this.id = id;
                this.element = this.createElement();
                this.timeSpent = 0;
                this.isHighlighted = false;
                this.lastUpdateTime = null;
                this.isOutOfScreen = false;
            }

            createElement() {
                const div = document.createElement('div');
                div.className = 'paragraph-chunk';
                div.id = `paragraph-${this.id}`;
                
                const textDiv = document.createElement('div');
                textDiv.textContent = this.text;
                
                const counterDiv = document.createElement('div');
                counterDiv.className = 'time-counter';
                counterDiv.textContent = '0.0s';
                
                div.appendChild(textDiv);
                div.appendChild(counterDiv);
                
                return div;
            }

            updateCounter() {
                const now = Date.now();
                if (this.isHighlighted && this.lastUpdateTime && !this.isOutOfScreen) {
                    this.timeSpent += now - this.lastUpdateTime;
                }
                this.lastUpdateTime = now;
                
                const seconds = (this.timeSpent / 1000).toFixed(1);
                const counterDiv = this.element.querySelector('.time-counter');
                counterDiv.textContent = `${seconds}s`;
            }

            setHighlight(isHighlighted, isRecording, isOutOfScreen = false) {
                this.isOutOfScreen = isOutOfScreen;
                if (!isRecording) {
                    isHighlighted = false;
                }
                
                this.isHighlighted = isHighlighted;
                if (isHighlighted && !isOutOfScreen) {
                    this.element.classList.add('highlight');
                    if (!this.lastUpdateTime) {
                        this.lastUpdateTime = Date.now();
                    }
                } else {
                    this.element.classList.remove('highlight');
                    if (this.lastUpdateTime) {
                        this.updateCounter();
                        this.lastUpdateTime = null;
                    }
                }
            }

            appendTo(container) {
                container.appendChild(this.element);
            }

            hideCounter(hide) {
                const counterDiv = this.element.querySelector('.time-counter');
                if (hide) {
                    counterDiv.classList.add('hidden');
                } else {
                    counterDiv.classList.remove('hidden');
                }
            }

            resetCounter() {
                this.timeSpent = 0;
                this.lastUpdateTime = null;
                this.isHighlighted = false;
                const counterDiv = this.element.querySelector('.time-counter');
                counterDiv.textContent = '0.0s';
            }
        }

        class FocusManager {
            constructor() {
                this.lastActiveTime = Date.now();
                this.lastActiveParagraph = null;
                this.outOfScreenTimer = null;
                this.TIMEOUT_DURATION = 4000;
                this.isObscured = false;
                this.isOutOfScreen = false;
            }

            handleCursorOutOfScreen() {
                this.isOutOfScreen = true;
                if (this.outOfScreenTimer) clearTimeout(this.outOfScreenTimer);
                
                this.outOfScreenTimer = setTimeout(() => {
                    document.querySelectorAll('.text-container').forEach(container => {
                        container.classList.add('fully-obscured');
                    });
                    this.lastActiveParagraph = null;
                    this.isObscured = true;
                }, this.TIMEOUT_DURATION);
            }

            handleCursorInScreen() {
                this.isOutOfScreen = false;
                if (this.outOfScreenTimer) {
                    clearTimeout(this.outOfScreenTimer);
                    this.outOfScreenTimer = null;
                }
                if (this.isObscured) {
                    document.querySelectorAll('.text-container').forEach(container => {
                        container.classList.remove('fully-obscured');
                    });
                    this.isObscured = false;
                }
            }

            updateLastActiveParagraph(paragraph) {
                if (!this.isObscured) {
                    this.lastActiveParagraph = paragraph;
                    this.lastActiveTime = Date.now();
                }
            }

            isActive() {
                return !this.isObscured;
            }
        }

        function isInVerticalBounds(cursorY, rect) {
            return cursorY >= rect.top && cursorY <= rect.bottom;
        }

        function findNearestParagraph(cursorX, cursorY, paragraphs) {
            // First determine which side the cursor is on
            const midScreen = window.innerWidth / 2;
            const isLeftSide = cursorX < midScreen;
            
            // Filter paragraphs based on side
            const sideParagraphs = paragraphs.filter(paragraph => {
                const rect = paragraph.element.getBoundingClientRect();
                return (cursorX < midScreen) === (rect.left < midScreen);
            });

            if (sideParagraphs.length === 0) return null;

            // Get the rectangles and sort them by vertical position
            const paragraphRects = sideParagraphs.map(paragraph => ({
                paragraph,
                rect: paragraph.element.getBoundingClientRect()
            })).sort((a, b) => a.rect.top - b.rect.top);

            // Check if cursor is directly within any paragraph's vertical bounds
            for (const {paragraph, rect} of paragraphRects) {
                if (isInVerticalBounds(cursorY, rect)) {
                    return paragraph;
                }
            }

            // If not within any paragraph, find the nearest paragraph boundary
            let nearestParagraph = null;
            let minDistance = Infinity;

            paragraphRects.forEach(({paragraph, rect}, index) => {
                // Check distance to top boundary
                let distanceToTop = Math.abs(cursorY - rect.top);
                if (distanceToTop < minDistance) {
                    minDistance = distanceToTop;
                    nearestParagraph = paragraph;
                }

                // Check distance to bottom boundary
                let distanceToBottom = Math.abs(cursorY - rect.bottom);
                if (distanceToBottom < minDistance) {
                    minDistance = distanceToBottom;
                    nearestParagraph = paragraph;
                }

                // If this is not the last paragraph, check the gap between this and next paragraph
                if (index < paragraphRects.length - 1) {
                    const nextRect = paragraphRects[index + 1].rect;
                    const gapMiddle = (rect.bottom + nextRect.top) / 2;
                    
                    if (cursorY > rect.bottom && cursorY < nextRect.top) {
                        // If cursor is in the gap, compare distances to adjacent paragraphs
                        const distanceToThis = Math.abs(cursorY - rect.bottom);
                        const distanceToNext = Math.abs(cursorY - nextRect.top);
                        if (distanceToThis <= distanceToNext) {
                            return paragraph;
                        } else {
                            return paragraphRects[index + 1].paragraph;
                        }
                    }
                }
            });

            return nearestParagraph;
        }

        function checkOverlap(cursor, paragraphs, isRecording, focusManager) {
            const cursorRect = cursor.getBoundingClientRect();
            const cursorX = cursorRect.left + cursorRect.width / 2;
            const cursorY = cursorRect.top + cursorRect.height / 2;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Simpler out-of-screen detection: if cursor is not visible in viewport
            if (cursorX < 0 || cursorY < 0 || 
                cursorX > viewportWidth || cursorY > viewportHeight || 
                !document.hasFocus()) {
                
                focusManager.handleCursorOutOfScreen();
                
                // Keep last active paragraph highlighted if within timeout
                if (focusManager.lastActiveParagraph && 
                    Date.now() - focusManager.lastActiveTime < focusManager.TIMEOUT_DURATION) {
                    focusManager.lastActiveParagraph.setHighlight(true, isRecording, true);
                }
                return;
            }

            focusManager.handleCursorInScreen();

            // Only proceed with paragraph detection if not obscured
            if (focusManager.isActive()) {
                const nearestParagraph = findNearestParagraph(cursorX, cursorY, paragraphs);
                
                paragraphs.forEach(paragraph => {
                    const isNearest = paragraph === nearestParagraph;
                    paragraph.setHighlight(isNearest, isRecording, false);
                    if (isNearest) {
                        focusManager.updateLastActiveParagraph(paragraph);
                    }
                });
            }
        }

        class Heatmap {
            constructor(canvas, container) {
                this.canvas = canvas;
                this.container = container;
                this.ctx = canvas.getContext('2d');
                this.points = [];
                this.maxPoints = 1000;
                this.radius = 30;
                this.intensity = 0.05;
                this.decay = 0.995;
                this.colorScale = [
                    { r: 0, g: 0, b: 255, a: 0 },
                    { r: 255, g: 0, b: 0, a: 0.5 }
                ];
                
                this.resizeCanvas();
                this.container.addEventListener('scroll', () => this.resizeCanvas());
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = this.container.scrollHeight;
                this.draw();
            }

            addPoint(x, y) {
                const rect = this.container.getBoundingClientRect();
                const scrollTop = this.container.scrollTop;
                const relativeX = x - rect.left;
                const relativeY = y - rect.top + scrollTop;

                if (relativeX >= 0 && relativeX <= rect.width &&
                    relativeY >= 0 && relativeY <= this.container.scrollHeight) {
                    this.points.push({ 
                        x: relativeX, 
                        y: relativeY, 
                        intensity: this.intensity 
                    });
                    if (this.points.length > this.maxPoints) {
                        this.points.shift();
                    }
                }
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            draw() {
                this.clear();
                
                const imageData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
                const data = imageData.data;

                this.points = this.points.filter(point => {
                    point.intensity *= this.decay;
                    return point.intensity > 0.001;
                });

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        let heat = 0;
                        
                        this.points.forEach(point => {
                            const distance = Math.sqrt(
                                Math.pow(x - point.x, 2) + 
                                Math.pow(y - point.y, 2)
                            );
                            if (distance < this.radius) {
                                heat += (1 - distance / this.radius) * point.intensity;
                            }
                        });

                        heat = Math.min(1, Math.max(0, heat));

                        const index = (y * this.canvas.width + x) * 4;
                        const color = this.getColor(heat);
                        data[index] = color.r;
                        data[index + 1] = color.g;
                        data[index + 2] = color.b;
                        data[index + 3] = Math.floor(color.a * 255);
                    }
                }

                this.ctx.putImageData(imageData, 0, 0);
            }

            getColor(value) {
                const color1 = this.colorScale[0];
                const color2 = this.colorScale[1];
                
                return {
                    r: Math.floor(color1.r + (color2.r - color1.r) * value),
                    g: Math.floor(color1.g + (color2.g - color1.g) * value),
                    b: Math.floor(color1.b + (color2.b - color1.b) * value),
                    a: color1.a + (color2.a - color1.a) * value
                };
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const leftText = `I have always loved objects of measurement and display such as our  family barometer, both real and imagined. Do you remember Frodo's  sword Sting in The Hobbit? It's one of those fantastic objects. Not  only is it perfectly made for its task-well-balanced, attractive, and  sharp-it has an additional and amazing ability: it detects the presence  of goblins and evil orcs. When danger approaches, Sting glows blue,  anticipating its own need and use. It is a trusty weapon, an infallible warning system, a handsome object, and a fantastic companion-for  a hobbit.

            Sting, the barometer, and so many other steampunk-era objectsvintage car and boat dashboards, analog dials, and stereo interfaceshave material qualities that I respond to. Not only are they delightful to  operate and live with, they have a knowingness about them, a possession of knowledge that they convey, an ability to amplify human abilities. Like a vintage clock, such instruments seem to carry the weight  of experience.

            Even as a kid, I imagined creating objects that were as handy as  Sting and as mystical as the barometer. In those hours I spent in the  workshop with my grandfather (avoiding the Thanksgiving or Christmas hubbub taking place upstairs), we would turn bowls on the lathe,  take apart clocks, build stereo speakers and bike rollers, dream up  and draw fantasy homes or airports. My curiosity carried through my  childhood: at robot camp one summer, we programmed a poodle-size  robot using a complicated series of codes called assembly language,  and, in high school, I learned to program on my first Apple He, making it spin out of control with a recursive algorithm.

            In college, computing opened my eyes to a new world of possibilities for what objects could already do and what they might eventually be able to do. A double major, I found that both physics and fine art  had their own thrilling languages for characterizing the physical world,  each with revelations and enlightenments. My graduate work at Harvard included the building of software-learning simulations like SimCity. Then I came to MIT's Media Lab, a place where programmers  mix with artists, musicians, and educators, and everyone experiments  with technology and computation, seeking to reinvent everything from  cinema to opera to medicine and education. There, I had another revelation: technology could enhance objects in ways that would come  close to, or even surpass, the qualities of the magical objects from folklore and science fiction that I have loved since I was a kid. To make  ordinary things as extraordinary and delightful to use and as pleasing  to live with as my father's barometer and my grandfather's tools, the  human-computer interaction needs to be freed from clicking and dragging. There can (and will) be real flying carpets and should be (and already are) Dick Tracy wrist communicators.`;

            const rightText = `The most pressing question underlying these competing trajectories is this: What is the most natural and desirable-even invisible-way  for human beings to interact with technology without requiring a new  set of skills or constantly needing to learn new languages, gestures, icons, color codes, or button combinations? This question has fascinated me for years, driven me to start up five technology companies,  and pushed me to pursue academic research and teaching at the Media Lab.

            I believe these trajectories-Terminal World, prosthetics/wearables, animism, and enchanted objects-are fluid and transitional. They will all bring some degree of value and will overlap and inform each other.  I have chosen to devote my time and energy to the fourth technology trajectory: enchanted objects. I won't abandon my smartphones or lose interest in the work of my colleagues who are developing wearabies and social robots. I simply believe that the most promising and pleasing future is one where technology infuses ordinary things with a  bit of magic to create a more satisfying interaction and evoke an emotional response.

            Think of this approach to technology as a realization of our fondest fantasies and wildest dreams. A reimagining of flying carpets, talking  mirrors, protective cloaks, animated brooms, and omniscient crystal  balls-as well as cherished everyday objects of our past lives, such as hallway barometers and woodworking tools-things we have always loved, dreamed about, and wanted in our lives. This book is about that reimagining and how to make it a reality. ENCHANTED OBJECTS  humans and machines will be preserved. I disagree. I understand that  category confusion provokes anxiety, that people become disturbed when they're not quite sure if they're talking to a machine or a person.

            But I also believe that natural human-computer interaction has more  benefits than risks. When I was in high school, the standard breakup line was "Let's just  be friends ." The snide retort was "If I wanted another friend, I would have gotten a dog." Given Facebook's and Linkedin's abilities to connect me with hundreds of loose ties (aka "friends"), I don't feel the need for a new set of artificial friends in my life, especially in the form  of awkward, sometimes dim-witted, and often brittle robots.`;

            let paragraphs = [];
            let isReadingMode = false;
            document.body.classList.add('calibration-mode');

            // Update control button handlers
            const startButton = document.getElementById('startButton');
            const cursorToggle = document.getElementById('cursorToggle');
            const timerToggle = document.getElementById('timerToggle');
            const cursor = document.getElementById('cursor');

            startButton.addEventListener('click', () => {
                if (!isReadingMode) {
                    isReadingMode = true;
                    document.body.classList.remove('calibration-mode');
                    document.body.classList.add('reading-mode');
                    startButton.disabled = true;
                    startButton.textContent = 'Reading Mode';
                    
                    // Show paragraphs with transition
                    paragraphs.forEach(paragraph => {
                        paragraph.element.style.transition = 'opacity 0.5s ease';
                        paragraph.element.style.opacity = '1';
                        paragraph.element.style.pointerEvents = 'auto';
                    });
                }
            });

            cursorToggle.addEventListener('change', () => {
                cursor.classList.toggle('invisible', !cursorToggle.checked);
            });

            timerToggle.addEventListener('change', () => {
                paragraphs.forEach(paragraph => {
                    paragraph.hideCounter(!timerToggle.checked);
                });
            });

            function populateContainer(containerId, text) {
                const paragraphTexts = text.split('\n\n').map(p => p.trim()).filter(p => p.length > 0);
                const container = document.getElementById(containerId);
                
                paragraphTexts.forEach((text, index) => {
                    const paragraph = new Paragraph(text, `${containerId}-${index}`);
                    paragraph.appendTo(container);
                    paragraphs.push(paragraph);
                });
            }

            // Populate both containers
            populateContainer('leftTextContainer', leftText);
            populateContainer('rightTextContainer', rightText);

            // Initialize heatmaps for both containers
            const leftContainer = document.getElementById('leftTextContainer');
            const rightContainer = document.getElementById('rightTextContainer');
            const leftHeatmapCanvas = document.getElementById('leftHeatmapCanvas');
            const rightHeatmapCanvas = document.getElementById('rightHeatmapCanvas');
            
            const leftHeatmap = new Heatmap(leftHeatmapCanvas, leftContainer);
            const rightHeatmap = new Heatmap(rightHeatmapCanvas, rightContainer);

            const heatmapToggle = document.getElementById('heatmapToggle');

            heatmapToggle.addEventListener('change', () => {
                leftHeatmapCanvas.classList.toggle('visible', heatmapToggle.checked);
                rightHeatmapCanvas.classList.toggle('visible', heatmapToggle.checked);
            });

            // Animation loop for both heatmaps
            function animate() {
                if (heatmapToggle.checked) {
                    leftHeatmap.draw();
                    rightHeatmap.draw();
                }
                requestAnimationFrame(animate);
            }
            animate();

            const focusManager = new FocusManager();
            window.focusManager = focusManager; // Make focusManager globally accessible

            // Update the interval to use focusManager
            setInterval(() => {
                if (isReadingMode) {
                    checkOverlap(cursor, paragraphs, true, focusManager);
                    if (heatmapToggle.checked) {
                        const cursorRect = cursor.getBoundingClientRect();
                        const cursorX = cursorRect.left + cursorRect.width / 2;
                        const cursorY = cursorRect.top + cursorRect.height / 2;
                        
                        leftHeatmap.addPoint(cursorX, cursorY);
                        rightHeatmap.addPoint(cursorX, cursorY);
                    }
                    paragraphs.forEach(paragraph => {
                        if (paragraph.isHighlighted) {
                            paragraph.updateCounter();
                        }
                    });
                }
            }, 100);
        });

        // Add event listener for visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const focusManager = window.focusManager; // You'll need to make focusManager globally accessible
                focusManager.handleCursorOutOfScreen();
            }
        });
    </script>
</body>
</html>
